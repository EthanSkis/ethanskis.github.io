<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snake — Minimal, Apple‑Style</title>
  <meta name="description" content="A clean, minimal, Apple‑style Snake game with touch controls, settings, and local high scores. Single‑file HTML."/>
  <style>
    :root {
      --bg: #f5f7fb;
      --panel: rgba(255,255,255,0.6);
      --panel-strong: rgba(255,255,255,0.85);
      --text: #0b0c0f;
      --muted: #6b7280;
      --accent: #0ea5e9; /* Sky */
      --good: #10b981;   /* Emerald */
      --warn: #f59e0b;   /* Amber */
      --danger: #ef4444; /* Red */
      --grid: rgba(0,0,0,0.06);
      --shadow: 0 10px 30px rgba(0,0,0,0.08);
      --radius: 18px;
    }
    [data-theme="dark"] {
      --bg: #0b0c10;
      --panel: rgba(23,26,33,0.6);
      --panel-strong: rgba(23,26,33,0.85);
      --text: #eef2ff;
      --muted: #9aa3b2;
      --accent: #38bdf8;
      --grid: rgba(255,255,255,0.06);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
      background: radial-gradient(1200px 800px at 80% -10%, rgba(14,165,233,0.12), transparent 60%),
                  radial-gradient(900px 700px at 10% 120%, rgba(16,185,129,0.12), transparent 60%),
                  var(--bg);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      letter-spacing: 0.2px;
    }

    .app {
      max-width: 980px;
      margin: 32px auto;
      padding: 0 20px 40px;
      display: grid;
      gap: 18px;
    }

    .hud {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 12px;
      align-items: center;
      backdrop-filter: saturate(160%) blur(18px);
      background: var(--panel);
      border: 1px solid rgba(0,0,0,0.06);
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      padding: 14px 16px;
    }
    .hud .left { display: flex; gap: 14px; align-items: center; flex-wrap: wrap; }
    .chip {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 8px 12px; border-radius: 999px; font-weight: 600; font-size: 14px;
      background: var(--panel-strong);
      border: 1px solid rgba(0,0,0,0.06);
    }
    .dot { width: 8px; height: 8px; border-radius: 999px; background: var(--accent); box-shadow: 0 0 0 3px rgba(56,189,248,0.2); }
    .chip.muted { background: transparent; border: 1px dashed rgba(0,0,0,0.12); color: var(--muted); font-weight: 500; }

    .actions { display: flex; gap: 8px; }
    .btn {
      appearance: none; border: 0; outline: none; cursor: pointer;
      display: inline-flex; align-items: center; justify-content: center; gap: 10px;
      height: 40px; padding: 0 14px; border-radius: 12px; font-weight: 600; font-size: 14px;
      background: var(--panel-strong); color: var(--text);
      border: 1px solid rgba(0,0,0,0.06);
      box-shadow: inset 0 -1px 0 rgba(255,255,255,0.25);
      transition: transform .08s ease, background .2s ease;
    }
    .btn:hover { transform: translateY(-1px); }
    .btn:active { transform: translateY(0); }

    .stage {
      position: relative;
      display: grid; place-items: center;
      background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.2));
      border: 1px solid rgba(0,0,0,0.06);
      border-radius: calc(var(--radius) + 6px);
      backdrop-filter: blur(10px) saturate(140%);
      box-shadow: var(--shadow);
      padding: 14px;
      min-height: 520px;
    }

    /* Canvas container keeps a neat square; canvas itself scales with DPR */
    .board {
      position: relative;
      width: min(90vw, 720px);
      aspect-ratio: 1 / 1;
      border-radius: 24px;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.06);
      background:
        linear-gradient(90deg, var(--grid) 1px, transparent 1px) 0 0 / calc(100%/24) 100%,
        linear-gradient(180deg, var(--grid) 1px, transparent 1px) 0 0 / 100% calc(100%/24),
        radial-gradient(1200px 700px at 0% 0%, rgba(14,165,233,0.1), transparent),
        radial-gradient(1200px 700px at 100% 100%, rgba(99,102,241,0.08), transparent),
        var(--panel-strong);
    }

    canvas { display: block; width: 100%; height: 100%; }

    .overlay {
      position: absolute; inset: 0; display: grid; place-items: center;
      background: linear-gradient(180deg, rgba(0,0,0,0.0), rgba(0,0,0,0.04));
      pointer-events: none; border-radius: inherit;
    }

    .toast {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      padding: 10px 14px; border-radius: 999px; font-weight: 600; font-size: 13px;
      background: var(--panel-strong); border: 1px solid rgba(0,0,0,0.06); color: var(--muted);
      box-shadow: var(--shadow);
    }

    dialog { border: none; border-radius: 16px; background: var(--panel-strong); color: var(--text); box-shadow: var(--shadow); width: min(92vw, 520px); }
    dialog::backdrop { backdrop-filter: blur(4px); background: rgba(0,0,0,0.2); }
    .sheet { padding: 18px; display: grid; gap: 14px; }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
    .row label { font-size: 14px; color: var(--muted); }
    .row input[type="range"] { width: 55%; }
    .row input[type="color"] { appearance: none; width: 34px; height: 24px; padding: 0; border: 0; background: none; }

    .touch {
      position: absolute; inset: auto 14px 14px auto; display: grid; gap: 10px;
      grid-template-areas:
        ". up ."
        "left . right"
        ". down .";
      pointer-events: none;
    }
    .pad { grid-area: var(--area); pointer-events: auto; width: 64px; height: 64px; border-radius: 16px; border: 1px solid rgba(0,0,0,0.08); background: var(--panel-strong); display: grid; place-items: center; box-shadow: var(--shadow); }
    .pad svg { width: 28px; height: 28px; opacity: .9; }

    @media (pointer:fine) and (hover:hover) {
      .touch { display: none; }
    }

    small.hint { color: var(--muted); text-align: center; }
  </style>
</head>
<body>
  <div class="app" id="app">
    <div class="hud">
      <div class="left">
        <span class="chip"><span class="dot"></span> <span>Snake</span></span>
        <span class="chip" id="scoreChip">Score · <b id="score">0</b></span>
        <span class="chip" id="hiChip">High · <b id="hiscore">0</b></span>
        <span class="chip muted" id="lvlChip">Lv <b id="level">1</b></span>
      </div>
      <div class="actions">
        <button class="btn" id="btnPlay" title="Play / Pause" aria-label="Play">
          <span id="iconPlay">▶︎</span>
        </button>
        <button class="btn" id="btnReset" title="New Game" aria-label="New Game">↺</button>
        <button class="btn" id="btnSettings" title="Settings" aria-label="Settings">⚙︎</button>
        <button class="btn" id="btnTheme" title="Theme" aria-label="Toggle theme">◐</button>
      </div>
    </div>

    <div class="stage">
      <div class="board">
        <canvas id="game" width="720" height="720"></canvas>
        <div class="overlay" aria-hidden="true"></div>
        <div class="toast" id="toast" hidden>Paused</div>
        <div class="touch">
          <button class="pad" style="--area:up" data-dir="up" aria-label="Up"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5"/><path d="m5 12 7-7 7 7"/></svg></button>
          <button class="pad" style="--area:left" data-dir="left" aria-label="Left"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5"/><path d="m12 5-7 7 7 7"/></svg></button>
          <button class="pad" style="--area:right" data-dir="right" aria-label="Right"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg></button>
          <button class="pad" style="--area:down" data-dir="down" aria-label="Down"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"/><path d="m19 12-7 7-7-7"/></svg></button>
        </div>
      </div>
      <small class="hint">Arrow keys / WASD to move · P to pause · R to restart · Settings for wrap/walls/speed · Works on touch</small>
    </div>
  </div>

  <!-- SETTINGS SHEET -->
  <dialog id="settings">
    <form method="dialog" class="sheet">
      <h3 style="margin:0 0 6px">Settings</h3>
      <div class="row"><label>Snake color</label><input type="color" id="optColor" value="#10b981"/></div>
      <div class="row"><label>Base speed <span style="color:var(--muted)">(<span id="spdVal">6</span> tiles/s)</span></label><input type="range" id="optSpeed" min="4" max="16" step="1" value="6"/></div>
      <div class="row"><label>Grid lines</label><input type="checkbox" id="optGrid" checked/></div>
      <div class="row"><label>Wrap around edges</label><input type="checkbox" id="optWrap" checked/></div>
      <div class="row"><label>Solid walls</label><input type="checkbox" id="optWalls"/></div>
      <div class="row"><label>Bonuses & power‑ups</label><input type="checkbox" id="optPower" checked/></div>
      <menu style="display:flex; gap:8px; justify-content:flex-end; margin:6px 0 0">
        <button class="btn" value="cancel">Close</button>
        <button class="btn" id="btnSave">Save</button>
      </menu>
    </form>
  </dialog>

  <!-- GAME OVER SHEET -->
  <dialog id="gameover">
    <div class="sheet">
      <h3 style="margin:0">Game Over</h3>
      <div class="row"><label>Score</label><b id="finalScore">0</b></div>
      <div class="row"><label>High score</label><b id="finalHi">0</b></div>
      <div class="row"><label>Level reached</label><b id="finalLv">1</b></div>
      <menu style="display:flex; gap:8px; justify-content:flex-end; margin:6px 0 0">
        <button class="btn" id="goShare" title="Copy score to clipboard">Share</button>
        <button class="btn" id="goAgain">Play again</button>
      </menu>
    </div>
  </dialog>

  <script>
  ;(() => {
    // ======= CONFIG =======
    const COLS = 24, ROWS = 24; // fixed logical grid
    const DPR = Math.max(1, Math.min(3, Math.floor(window.devicePixelRatio || 1)));
    const STORAGE = {
      hi: 'snake_hiscore_v1',
      settings: 'snake_settings_v1'
    };

    const $ = sel => document.querySelector(sel);
    const canvas = $('#game');
    const ctx = canvas.getContext('2d');
    const scoreEl = $('#score'), hiEl = $('#hiscore'), levelEl = $('#level');
    const btnPlay = $('#btnPlay'), btnReset = $('#btnReset');
    const btnSettings = $('#btnSettings'), btnTheme = $('#btnTheme');
    const toast = $('#toast');

    // Settings dialog elements
    const dlgSettings = $('#settings');
    const optColor = $('#optColor');
    const optSpeed = $('#optSpeed');
    const optGrid = $('#optGrid');
    const optWrap = $('#optWrap');
    const optWalls = $('#optWalls');
    const optPower = $('#optPower');
    const spdVal = $('#spdVal');

    // Game over dialog elements
    const dlgOver = $('#gameover');
    const goAgain = $('#goAgain');
    const goShare = $('#goShare');
    const finalScore = $('#finalScore');
    const finalHi = $('#finalHi');
    const finalLv = $('#finalLv');

    // ======= STATE =======
    let settings = loadSettings();
    applyThemeFromSystem();

    // Canvas scaling (CSS 720×720, internal * DPR)
    function resizeCanvas() {
      const cssSize = canvas.getBoundingClientRect().width; // square
      canvas.width = Math.round(cssSize * DPR);
      canvas.height = Math.round(cssSize * DPR);
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(canvas.width / COLS, canvas.height / ROWS); // scale units to grid cells
      ctx.imageSmoothingEnabled = false;
    }
    new ResizeObserver(resizeCanvas).observe(canvas);
    resizeCanvas();

    // Hi score
    let hiscore = Number(localStorage.getItem(STORAGE.hi) || 0);
    hiEl.textContent = hiscore;

    // Utility
    const randInt = n => Math.floor(Math.random()*n);
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    // Game entities
    class Snake {
      constructor() {
        const mid = { x: Math.floor(COLS/2), y: Math.floor(ROWS/2) };
        this.body = [mid, {x: mid.x-1, y: mid.y}, {x: mid.x-2, y: mid.y}];
        this.dir = {x: 1, y: 0};
        this.nextDir = this.dir;
        this.growBy = 0;
      }
      setDir(x, y) {
        // prevent reversing into self
        if (this.body.length > 1) {
          const h = this.body[0];
          const n = this.body[1];
          if (h.x + x === n.x && h.y + y === n.y) return;
        }
        this.nextDir = {x, y};
      }
      step() {
        this.dir = this.nextDir;
        const head = this.body[0];
        let nx = head.x + this.dir.x;
        let ny = head.y + this.dir.y;

        if (settings.walls) {
          // hit borders = collision
          if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) return false;
        } else if (settings.wrap) {
          if (nx < 0) nx = COLS - 1; else if (nx >= COLS) nx = 0;
          if (ny < 0) ny = ROWS - 1; else if (ny >= ROWS) ny = 0;
        } else {
          if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) return false;
        }

        // move
        this.body.unshift({x: nx, y: ny});
        if (this.growBy > 0) this.growBy--; else this.body.pop();
        return true;
      }
      intersects(pt, ignoreHead=false) {
        return this.body.some((p,i) => (ignoreHead && i===0) ? false : (p.x===pt.x && p.y===pt.y));
      }
    }

    class Food {
      constructor(kind='normal', ttl=0) { this.kind=kind; this.ttl=ttl; this.pos=this.randomPos(); }
      randomPos() {
        let p;
        do { p = {x: randInt(COLS), y: randInt(ROWS)}; } while (snake.intersects(p));
        return p;
      }
    }

    // Minimal particle effect when eating
    const particles = [];
    function spawnParticles(x,y, color) {
      for (let i=0;i<10;i++) particles.push({x,y, vx:(Math.random()-0.5)*0.8, vy:(Math.random()-0.5)*0.8, life: 18, color});
    }

    // ======= GAME LOOP =======
    let snake, food, bonus=null, score, level, speed, paused = true, over = false;
    let acc = 0, lastTime = performance.now();

    function newGame() {
      snake = new Snake();
      food = new Food('normal');
      bonus = null;
      score = 0; level = 1; speed = settings.speed; // tiles per second
      paused = true; over = false; acc = 0; lastTime = performance.now();
      updateHUD();
      showToast('Press ▶︎ to start');
      draw();
    }

    function updateHUD() {
      scoreEl.textContent = score;
      hiEl.textContent = hiscore;
      levelEl.textContent = level;
    }

    function maybeLevelUp() {
      const step = 6; // every N foods
      const nextLevelAt = step * level;
      if (score >= nextLevelAt) {
        level++;
        speed = Math.min(18, speed + 1);
        showToast(`Level ${level}`);
      }
    }

    function spawnBonus() {
      if (!settings.power) return;
      if (bonus || Math.random() > 0.22) return; // chance gate
      bonus = new Food('bonus', 7 * 60); // ~7s at 60fps
    }

    function tick() {
      if (paused || over) return;
      // advance snake by one tile
      const ok = snake.step();
      if (!ok) return gameOver();

      const head = snake.body[0];

      // self collision
      if (snake.intersects(head, true)) return gameOver();

      // eat normal food
      if (head.x===food.pos.x && head.y===food.pos.y) {
        score += 1;
        snake.growBy += 1;
        spawnParticles(head.x+0.5, head.y+0.5, settings.color);
        food = new Food('normal');
        spawnBonus();
        maybeLevelUp();
      }

      // eat bonus
      if (bonus && head.x===bonus.pos.x && head.y===bonus.pos.y) {
        score += 5;
        snake.growBy += 2;
        spawnParticles(head.x+0.5, head.y+0.5, '#f59e0b');
        bonus = null;
        maybeLevelUp();
      }

      // decay bonus
      if (bonus) { bonus.ttl--; if (bonus.ttl<=0) bonus = null; }

      // decay particles
      for (let i=particles.length-1;i>=0;i--) {
        const p = particles[i];
        p.x += p.vx; p.y += p.vy; p.life--; if (p.life<=0) particles.splice(i,1);
      }
    }

    function draw() {
      // logical units are tiles; we scaled context to COLS×ROWS
      // clear
      ctx.save();
      ctx.clearRect(0,0,COLS,ROWS);

      // optional light grid overlay handled by CSS background; draw overlays only
      if (!settings.grid) {
        // cover CSS grid by drawing a panel background
        ctx.fillStyle = 'rgba(0,0,0,0.0)';
        ctx.fillRect(0,0,COLS,ROWS);
      }

      // draw bonus first (ring)
      if (bonus) {
        const {x,y} = bonus.pos;
        ctx.fillStyle = '#f59e0bb8';
        roundRect(ctx, x+0.12, y+0.12, 0.76, 0.76, 0.2);
        ctx.fill();
        // timer arc
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(245,158,11,0.9)';
        ctx.lineWidth = 0.12;
        const pct = bonus.ttl / (7*60);
        ctx.arc(x+0.5, y+0.5, 0.45, -Math.PI/2, -Math.PI/2 + 2*Math.PI*pct);
        ctx.stroke();
      }

      // draw food
      ctx.fillStyle = '#ef4444cc';
      roundRect(ctx, food.pos.x+0.16, food.pos.y+0.16, 0.68, 0.68, 0.18);
      ctx.fill();

      // draw snake
      ctx.fillStyle = hexToRgba(settings.color, 0.92);
      snake.body.forEach((p,i) => {
        const r = i===0 ? 0.26 : 0.22;
        roundRect(ctx, p.x+0.08, p.y+0.08, 0.84, 0.84, 0.24);
        ctx.fill();
        if (i===0) {
          // eyes
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          const ex = p.x + (snake.dir.x!==0 ? 0.65 : 0.35);
          const ey = p.y + (snake.dir.y===1 ? 0.65 : snake.dir.y===-1 ? 0.35 : 0.5);
          ctx.beginPath(); ctx.arc(ex-0.14, ey-0.14, 0.06, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(ex, ey, 0.06, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle = hexToRgba(settings.color, 0.92);
        }
      });

      // particles
      particles.forEach(p => {
        ctx.globalAlpha = clamp(p.life/18, 0, 1);
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, 0.08, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
      });

      ctx.restore();
    }

    function loop(t) {
      const dt = Math.min(100, t - lastTime); // clamp large jumps
      lastTime = t;
      if (!paused && !over) {
        acc += dt;
        const stepMs = 1000 / speed;
        while (acc >= stepMs) { tick(); acc -= stepMs; }
      }
      draw();
      requestAnimationFrame(loop);
    }

    function gameOver() {
      over = true; paused = true;
      if (score > hiscore) { hiscore = score; localStorage.setItem(STORAGE.hi, String(hiscore)); }
      finalScore.textContent = score;
      finalHi.textContent = hiscore;
      finalLv.textContent = level;
      dlgOver.showModal();
    }

    // ======= INPUT =======
    const keyDirs = {
      ArrowUp: [0,-1], ArrowDown: [0,1], ArrowLeft: [-1,0], ArrowRight: [1,0],
      w: [0,-1], s: [0,1], a: [-1,0], d: [1,0], W:[0,-1], S:[0,1], A:[-1,0], D:[1,0]
    };
    document.addEventListener('keydown', e => {
      if (keyDirs[e.key]) { e.preventDefault(); const [x,y] = keyDirs[e.key]; snake.setDir(x,y); }
      if (e.key==='p' || e.key==='P') togglePause();
      if (e.key==='r' || e.key==='R') { newGame(); }
      if (e.key===' ') { e.preventDefault(); togglePause(); }
    }, { passive:false });

    // Buttons
    btnPlay.addEventListener('click', togglePause);
    btnReset.addEventListener('click', () => newGame());
    btnSettings.addEventListener('click', () => openSettings());
    btnTheme.addEventListener('click', toggleTheme);

    // Touch controls
    document.querySelectorAll('.pad').forEach(el => {
      el.addEventListener('click', () => {
        const dir = el.dataset.dir;
        const map = {up:[0,-1], down:[0,1], left:[-1,0], right:[1,0]};
        const [x,y] = map[dir];
        snake.setDir(x,y);
        if (paused && !over) togglePause(false);
      });
    });

    // ======= SETTINGS =======
    function openSettings() {
      // preload current
      optColor.value = settings.color;
      optSpeed.value = String(settings.speed);
      spdVal.textContent = settings.speed;
      optGrid.checked = settings.grid;
      optWrap.checked = settings.wrap;
      optWalls.checked = settings.walls;
      optPower.checked = settings.power;
      dlgSettings.showModal();
    }

    optSpeed.addEventListener('input', () => { spdVal.textContent = optSpeed.value; });

    $('#btnSave').addEventListener('click', (e) => {
      e.preventDefault();
      settings.color = optColor.value;
      settings.speed = Number(optSpeed.value);
      settings.grid = !!optGrid.checked;
      settings.wrap = !!optWrap.checked;
      settings.walls = !!optWalls.checked;
      settings.power = !!optPower.checked;
      // prevent invalid combo: walls overrides wrap
      if (settings.walls) settings.wrap = false;
      saveSettings();
      dlgSettings.close();
      showToast('Saved');
      // apply immediately
      speed = settings.speed;
    });

    function loadSettings() {
      const d = { color: '#10b981', speed: 6, grid: true, wrap: true, walls: false, power: true };
      try { Object.assign(d, JSON.parse(localStorage.getItem(STORAGE.settings) || '{}')); } catch {}
      return d;
    }
    function saveSettings() { localStorage.setItem(STORAGE.settings, JSON.stringify(settings)); }

    // Theme
    function applyThemeFromSystem() {
      const stored = localStorage.getItem('snake_theme');
      const dark = stored ? stored==='dark' : window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      document.documentElement.setAttribute('data-theme', dark ? 'dark' : 'light');
    }
    function toggleTheme() {
      const cur = document.documentElement.getAttribute('data-theme');
      const next = cur==='dark' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', next);
      localStorage.setItem('snake_theme', next);
    }

    // Pause / Play
    function togglePause(forceState) {
      if (over) { newGame(); return; }
      if (typeof forceState==='boolean') paused = !forceState ? true : false; // (unused)
      paused = !paused;
      if (!paused) { lastTime = performance.now(); hideToast(); btnPlay.setAttribute('aria-label','Pause'); $('#iconPlay').textContent = '⏸'; }
      else { showToast('Paused'); btnPlay.setAttribute('aria-label','Play'); $('#iconPlay').textContent = '▶︎'; }
    }

    function showToast(msg) { toast.textContent = msg; toast.hidden = false; clearTimeout(showToast._t); showToast._t = setTimeout(() => { hideToast(); }, 1600); }
    function hideToast() { toast.hidden = true; }

    // Game over actions
    goAgain.addEventListener('click', () => { dlgOver.close(); newGame(); });
    goShare.addEventListener('click', async () => {
      const text = `I scored ${score} on Minimal Snake (Lv ${level}). Can you beat it?`;
      try {
        if (navigator.share) await navigator.share({ text, title: 'Minimal Snake' });
        else {
          await navigator.clipboard.writeText(text);
          showToast('Copied');
        }
      } catch {}
    });

    // Helpers
    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    function hexToRgba(hex, a=1) {
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (!m) return hex; const r=parseInt(m[1],16), g=parseInt(m[2],16), b=parseInt(m[3],16);
      return `rgba(${r},${g},${b},${a})`;
    }

    // Start
    newGame();
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
